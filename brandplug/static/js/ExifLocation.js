/**
 * Require the module at `name`.
 *
 * @param {String} name
 * @return {Object} exports
 * @api public
 */

function require(name) {
  var module = require.modules[name];
  if (!module) throw new Error('failed to require "' + name + '"');

  if (!('exports' in module) && typeof module.definition === 'function') {
    module.client = module.component = true;
    module.definition.call(this, module.exports = {}, module);
    delete module.definition;
  }

  return module.exports;
}

/**
 * Meta info, accessible in the global scope unless you use AMD option.
 */

require.loader = 'component';

/**
 * Internal helper object, contains a sorting function for semantiv versioning
 */
require.helper = {};
require.helper.semVerSort = function(a, b) {
  var aArray = a.version.split('.');
  var bArray = b.version.split('.');
  for (var i=0; i<aArray.length; ++i) {
    var aInt = parseInt(aArray[i], 10);
    var bInt = parseInt(bArray[i], 10);
    if (aInt === bInt) {
      var aLex = aArray[i].substr((""+aInt).length);
      var bLex = bArray[i].substr((""+bInt).length);
      if (aLex === '' && bLex !== '') return 1;
      if (aLex !== '' && bLex === '') return -1;
      if (aLex !== '' && bLex !== '') return aLex > bLex ? 1 : -1;
      continue;
    } else if (aInt > bInt) {
      return 1;
    } else {
      return -1;
    }
  }
  return 0;
}

/**
 * Find and require a module which name starts with the provided name.
 * If multiple modules exists, the highest semver is used. 
 * This function can only be used for remote dependencies.

 * @param {String} name - module name: `user~repo`
 * @param {Boolean} returnPath - returns the canonical require path if true, 
 *                               otherwise it returns the epxorted module
 */
require.latest = function (name, returnPath) {
  function showError(name) {
    throw new Error('failed to find latest module of "' + name + '"');
  }
  // only remotes with semvers, ignore local files conataining a '/'
  var versionRegexp = /(.*)~(.*)@v?(\d+\.\d+\.\d+[^\/]*)$/;
  var remoteRegexp = /(.*)~(.*)/;
  if (!remoteRegexp.test(name)) showError(name);
  var moduleNames = Object.keys(require.modules);
  var semVerCandidates = [];
  var otherCandidates = []; // for instance: name of the git branch
  for (var i=0; i<moduleNames.length; i++) {
    var moduleName = moduleNames[i];
    if (new RegExp(name + '@').test(moduleName)) {
        var version = moduleName.substr(name.length+1);
        var semVerMatch = versionRegexp.exec(moduleName);
        if (semVerMatch != null) {
          semVerCandidates.push({version: version, name: moduleName});
        } else {
          otherCandidates.push({version: version, name: moduleName});
        } 
    }
  }
  if (semVerCandidates.concat(otherCandidates).length === 0) {
    showError(name);
  }
  if (semVerCandidates.length > 0) {
    var module = semVerCandidates.sort(require.helper.semVerSort).pop().name;
    if (returnPath === true) {
      return module;
    }
    return require(module);
  }
  // if the build contains more than one branch of the same module
  // you should not use this funciton
  var module = otherCandidates.sort(function(a, b) {return a.name > b.name})[0].name;
  if (returnPath === true) {
    return module;
  }
  return require(module);
}

/**
 * Registered modules.
 */

require.modules = {};

/**
 * Register module at `name` with callback `definition`.
 *
 * @param {String} name
 * @param {Function} definition
 * @api private
 */

require.register = function (name, definition) {
  require.modules[name] = {
    definition: definition
  };
};

/**
 * Define a module's exports immediately with `exports`.
 *
 * @param {String} name
 * @param {Generic} exports
 * @api private
 */

require.define = function (name, exports) {
  require.modules[name] = {
    exports: exports
  };
};
require.register("mattiasw~exifreader@v1.1.1", Function("exports, module",
"// Generated by CoffeeScript 1.6.2\n\
/*\n\
# ExifReader 1.1.1\n\
# http://github.com/mattiasw/exifreader\n\
# Copyright (C) 2011-2014  Mattias Wallander <mattias@wallander.eu>\n\
# Licensed under the GNU Lesser General Public License version 3 or later\n\
# See license text at http://www.gnu.org/licenses/lgpl.txt\n\
*/\n\
\n\
\n\
(function() {\n\
  (typeof exports !== \"undefined\" && exports !== null ? exports : this).ExifReader = (function() {\n\
    ExifReader.prototype._MIN_DATA_BUFFER_LENGTH = 2;\n\
\n\
    ExifReader.prototype._JPEG_ID_SIZE = 2;\n\
\n\
    ExifReader.prototype._JPEG_ID = 0xffd8;\n\
\n\
    ExifReader.prototype._APP_MARKER_SIZE = 2;\n\
\n\
    ExifReader.prototype._APP0_MARKER = 0xffe0;\n\
\n\
    ExifReader.prototype._APP1_MARKER = 0xffe1;\n\
\n\
    ExifReader.prototype._APP15_MARKER = 0xffef;\n\
\n\
    ExifReader.prototype._APP_ID_OFFSET = 4;\n\
\n\
    ExifReader.prototype._BYTES_Exif = 0x45786966;\n\
\n\
    ExifReader.prototype._TIFF_HEADER_OFFSET = 10;\n\
\n\
    ExifReader.prototype._BYTE_ORDER_BIG_ENDIAN = 0x4949;\n\
\n\
    ExifReader.prototype._BYTE_ORDER_LITTLE_ENDIAN = 0x4d4d;\n\
\n\
    function ExifReader() {\n\
      var _this = this;\n\
\n\
      this._getTagValueAt = {\n\
        1: function(offset) {\n\
          return _this._getByteAt(offset);\n\
        },\n\
        2: function(offset) {\n\
          return _this._getAsciiAt(offset);\n\
        },\n\
        3: function(offset) {\n\
          return _this._getShortAt(offset);\n\
        },\n\
        4: function(offset) {\n\
          return _this._getLongAt(offset);\n\
        },\n\
        5: function(offset) {\n\
          return _this._getRationalAt(offset);\n\
        },\n\
        7: function(offset) {\n\
          return _this._getUndefinedAt(offset);\n\
        },\n\
        9: function(offset) {\n\
          return _this._getSlongAt(offset);\n\
        },\n\
        10: function(offset) {\n\
          return _this._getSrationalAt(offset);\n\
        }\n\
      };\n\
      this._tiffHeaderOffset = 0;\n\
    }\n\
\n\
    /*\n\
    # Loads all the Exif tags from the specified image file buffer.\n\
    #\n\
    # data ArrayBuffer Image file data\n\
    */\n\
\n\
\n\
    ExifReader.prototype.load = function(data) {\n\
      return this.loadView(new DataView(data));\n\
    };\n\
\n\
    /*\n\
    # Loads all the Exif tags from the specified image file buffer view. Probably\n\
    # used when DataView isn't supported by the browser.\n\
    #\n\
    # @_dataView DataView Image file data view\n\
    */\n\
\n\
\n\
    ExifReader.prototype.loadView = function(_dataView) {\n\
      this._dataView = _dataView;\n\
      this._tags = {};\n\
      this._checkImageHeader();\n\
      this._readTags();\n\
      return this._dataView = null;\n\
    };\n\
\n\
    ExifReader.prototype._checkImageHeader = function() {\n\
      if (this._dataView.byteLength < this._MIN_DATA_BUFFER_LENGTH || this._dataView.getUint16(0, false) !== this._JPEG_ID) {\n\
        throw new Error('Invalid image format');\n\
      }\n\
      this._parseAppMarkers(this._dataView);\n\
      if (!this._hasExifData()) {\n\
        throw new Error('No Exif data');\n\
      }\n\
    };\n\
\n\
    ExifReader.prototype._parseAppMarkers = function(dataView) {\n\
      var appMarkerPosition, fieldLength, _results;\n\
\n\
      appMarkerPosition = this._JPEG_ID_SIZE;\n\
      _results = [];\n\
      while (true) {\n\
        if (dataView.byteLength < appMarkerPosition + this._APP_ID_OFFSET + 5) {\n\
          break;\n\
        }\n\
        if (this._isApp1ExifMarker(dataView, appMarkerPosition)) {\n\
          fieldLength = dataView.getUint16(appMarkerPosition + this._APP_MARKER_SIZE, false);\n\
          this._tiffHeaderOffset = appMarkerPosition + this._TIFF_HEADER_OFFSET;\n\
        } else if (this._isAppMarker(dataView, appMarkerPosition)) {\n\
          fieldLength = dataView.getUint16(appMarkerPosition + this._APP_MARKER_SIZE, false);\n\
        } else {\n\
          break;\n\
        }\n\
        _results.push(appMarkerPosition += this._APP_MARKER_SIZE + fieldLength);\n\
      }\n\
      return _results;\n\
    };\n\
\n\
    ExifReader.prototype._isApp1ExifMarker = function(dataView, appMarkerPosition) {\n\
      return dataView.getUint16(appMarkerPosition, false) === this._APP1_MARKER && dataView.getUint32(appMarkerPosition + this._APP_ID_OFFSET, false) === this._BYTES_Exif && dataView.getUint8(appMarkerPosition + this._APP_ID_OFFSET + 4, false) === 0x00;\n\
    };\n\
\n\
    ExifReader.prototype._isAppMarker = function(dataView, appMarkerPosition) {\n\
      var appMarker;\n\
\n\
      appMarker = dataView.getUint16(appMarkerPosition, false);\n\
      return appMarker >= this._APP0_MARKER && appMarker <= this._APP15_MARKER;\n\
    };\n\
\n\
    ExifReader.prototype._hasExifData = function() {\n\
      return this._tiffHeaderOffset !== 0;\n\
    };\n\
\n\
    ExifReader.prototype._readTags = function() {\n\
      this._setByteOrder();\n\
      this._read0thIfd();\n\
      this._readExifIfd();\n\
      this._readGpsIfd();\n\
      return this._readInteroperabilityIfd();\n\
    };\n\
\n\
    ExifReader.prototype._setByteOrder = function() {\n\
      if (this._dataView.getUint16(this._tiffHeaderOffset) === this._BYTE_ORDER_BIG_ENDIAN) {\n\
        return this._littleEndian = true;\n\
      } else if (this._dataView.getUint16(this._tiffHeaderOffset) === this._BYTE_ORDER_LITTLE_ENDIAN) {\n\
        return this._littleEndian = false;\n\
      } else {\n\
        throw new Error('Illegal byte order value. Faulty image.');\n\
      }\n\
    };\n\
\n\
    ExifReader.prototype._read0thIfd = function() {\n\
      var ifdOffset;\n\
\n\
      ifdOffset = this._getIfdOffset();\n\
      return this._readIfd('0th', ifdOffset);\n\
    };\n\
\n\
    ExifReader.prototype._getIfdOffset = function() {\n\
      return this._tiffHeaderOffset + this._getLongAt(this._tiffHeaderOffset + 4);\n\
    };\n\
\n\
    ExifReader.prototype._readExifIfd = function() {\n\
      var ifdOffset;\n\
\n\
      if (this._tags['Exif IFD Pointer'] != null) {\n\
        ifdOffset = this._tiffHeaderOffset + this._tags['Exif IFD Pointer'].value;\n\
        return this._readIfd('exif', ifdOffset);\n\
      }\n\
    };\n\
\n\
    ExifReader.prototype._readGpsIfd = function() {\n\
      var ifdOffset;\n\
\n\
      if (this._tags['GPS Info IFD Pointer'] != null) {\n\
        ifdOffset = this._tiffHeaderOffset + this._tags['GPS Info IFD Pointer'].value;\n\
        return this._readIfd('gps', ifdOffset);\n\
      }\n\
    };\n\
\n\
    ExifReader.prototype._readInteroperabilityIfd = function() {\n\
      var ifdOffset;\n\
\n\
      if (this._tags['Interoperability IFD Pointer'] != null) {\n\
        ifdOffset = this._tiffHeaderOffset + this._tags['Interoperability IFD Pointer'].value;\n\
        return this._readIfd('interoperability', ifdOffset);\n\
      }\n\
    };\n\
\n\
    ExifReader.prototype._readIfd = function(ifdType, offset) {\n\
      var fieldIndex, numberOfFields, tag, _i, _results;\n\
\n\
      numberOfFields = this._getShortAt(offset);\n\
      offset += 2;\n\
      _results = [];\n\
      for (fieldIndex = _i = 0; 0 <= numberOfFields ? _i < numberOfFields : _i > numberOfFields; fieldIndex = 0 <= numberOfFields ? ++_i : --_i) {\n\
        tag = this._readTag(ifdType, offset);\n\
        if (tag !== void 0) {\n\
          this._tags[tag.name] = {\n\
            'value': tag.value,\n\
            'description': tag.description\n\
          };\n\
        }\n\
        _results.push(offset += 12);\n\
      }\n\
      return _results;\n\
    };\n\
\n\
    ExifReader.prototype._readTag = function(ifdType, offset) {\n\
      var tagCode, tagCount, tagDescription, tagName, tagType, tagValue, tagValueOffset;\n\
\n\
      tagCode = this._getShortAt(offset);\n\
      tagType = this._getShortAt(offset + 2);\n\
      tagCount = this._getLongAt(offset + 4);\n\
      if (this._typeSizes[tagType] === void 0) {\n\
        return void 0;\n\
      }\n\
      if (this._typeSizes[tagType] * tagCount <= 4) {\n\
        tagValue = this._getTagValue(offset + 8, tagType, tagCount);\n\
      } else {\n\
        tagValueOffset = this._getLongAt(offset + 8);\n\
        tagValue = this._getTagValue(this._tiffHeaderOffset + tagValueOffset, tagType, tagCount);\n\
      }\n\
      if (tagType === this._tagTypes['ASCII']) {\n\
        tagValue = this._splitNullSeparatedAsciiString(tagValue);\n\
      }\n\
      if (this._tagNames[ifdType][tagCode] != null) {\n\
        if ((this._tagNames[ifdType][tagCode]['name'] != null) && (this._tagNames[ifdType][tagCode]['description'] != null)) {\n\
          tagName = this._tagNames[ifdType][tagCode]['name'];\n\
          tagDescription = this._tagNames[ifdType][tagCode]['description'](tagValue);\n\
        } else {\n\
          tagName = this._tagNames[ifdType][tagCode];\n\
          if (tagValue instanceof Array) {\n\
            tagDescription = tagValue.join(', ');\n\
          } else {\n\
            tagDescription = tagValue;\n\
          }\n\
        }\n\
        return {\n\
          'name': tagName,\n\
          'value': tagValue,\n\
          'description': tagDescription\n\
        };\n\
      } else {\n\
        return {\n\
          'name': \"undefined-\" + tagCode,\n\
          'value': tagValue,\n\
          'description': tagValue\n\
        };\n\
      }\n\
    };\n\
\n\
    ExifReader.prototype._getTagValue = function(offset, type, count) {\n\
      var tagValue, value, valueIndex;\n\
\n\
      value = (function() {\n\
        var _i, _results;\n\
\n\
        _results = [];\n\
        for (valueIndex = _i = 0; 0 <= count ? _i < count : _i > count; valueIndex = 0 <= count ? ++_i : --_i) {\n\
          tagValue = this._getTagValueAt[type](offset);\n\
          offset += this._typeSizes[type];\n\
          _results.push(tagValue);\n\
        }\n\
        return _results;\n\
      }).call(this);\n\
      if (value.length === 1) {\n\
        value = value[0];\n\
      } else if (type === this._tagTypes['ASCII']) {\n\
        value = this._getAsciiValue(value);\n\
      }\n\
      return value;\n\
    };\n\
\n\
    ExifReader.prototype._getAsciiValue = function(charArray) {\n\
      var charCode, newCharArray;\n\
\n\
      return newCharArray = (function() {\n\
        var _i, _len, _results;\n\
\n\
        _results = [];\n\
        for (_i = 0, _len = charArray.length; _i < _len; _i++) {\n\
          charCode = charArray[_i];\n\
          _results.push(String.fromCharCode(charCode));\n\
        }\n\
        return _results;\n\
      })();\n\
    };\n\
\n\
    ExifReader.prototype._getByteAt = function(offset) {\n\
      return this._dataView.getUint8(offset);\n\
    };\n\
\n\
    ExifReader.prototype._getAsciiAt = function(offset) {\n\
      return this._dataView.getUint8(offset);\n\
    };\n\
\n\
    ExifReader.prototype._getShortAt = function(offset) {\n\
      return this._dataView.getUint16(offset, this._littleEndian);\n\
    };\n\
\n\
    ExifReader.prototype._getLongAt = function(offset) {\n\
      return this._dataView.getUint32(offset, this._littleEndian);\n\
    };\n\
\n\
    ExifReader.prototype._getRationalAt = function(offset) {\n\
      return this._getLongAt(offset) / this._getLongAt(offset + 4);\n\
    };\n\
\n\
    ExifReader.prototype._getUndefinedAt = function(offset) {\n\
      return this._getByteAt(offset);\n\
    };\n\
\n\
    ExifReader.prototype._getSlongAt = function(offset) {\n\
      return this._dataView.getInt32(offset, this._littleEndian);\n\
    };\n\
\n\
    ExifReader.prototype._getSrationalAt = function(offset) {\n\
      return this._getSlongAt(offset) / this._getSlongAt(offset + 4);\n\
    };\n\
\n\
    ExifReader.prototype._splitNullSeparatedAsciiString = function(string) {\n\
      var character, i, tagValue, _i, _len;\n\
\n\
      tagValue = [];\n\
      i = 0;\n\
      for (_i = 0, _len = string.length; _i < _len; _i++) {\n\
        character = string[_i];\n\
        if (character === '\\x00') {\n\
          i++;\n\
          continue;\n\
        }\n\
        if (tagValue[i] == null) {\n\
          tagValue[i] = '';\n\
        }\n\
        tagValue[i] += character;\n\
      }\n\
      return tagValue;\n\
    };\n\
\n\
    ExifReader.prototype._typeSizes = {\n\
      1: 1,\n\
      2: 1,\n\
      3: 2,\n\
      4: 4,\n\
      5: 8,\n\
      7: 1,\n\
      9: 4,\n\
      10: 8\n\
    };\n\
\n\
    ExifReader.prototype._tagTypes = {\n\
      'BYTE': 1,\n\
      'ASCII': 2,\n\
      'SHORT': 3,\n\
      'LONG': 4,\n\
      'RATIONAL': 5,\n\
      'UNDEFINED': 7,\n\
      'SLONG': 9,\n\
      'SRATIONAL': 10\n\
    };\n\
\n\
    ExifReader.prototype._tagNames = {\n\
      '0th': {\n\
        0x0100: 'ImageWidth',\n\
        0x0101: 'ImageLength',\n\
        0x0102: 'BitsPerSample',\n\
        0x0103: 'Compression',\n\
        0x0106: 'PhotometricInterpretation',\n\
        0x010e: 'ImageDescription',\n\
        0x010f: 'Make',\n\
        0x0110: 'Model',\n\
        0x0111: 'StripOffsets',\n\
        0x0112: {\n\
          'name': 'Orientation',\n\
          'description': function(value) {\n\
            switch (value) {\n\
              case 1:\n\
                return 'top-left';\n\
              case 2:\n\
                return 'top-right';\n\
              case 3:\n\
                return 'bottom-right';\n\
              case 4:\n\
                return 'bottom-left';\n\
              case 5:\n\
                return 'left-top';\n\
              case 6:\n\
                return 'right-top';\n\
              case 7:\n\
                return 'right-bottom';\n\
              case 8:\n\
                return 'left-bottom';\n\
              default:\n\
                return 'Undefined';\n\
            }\n\
          }\n\
        },\n\
        0x0115: 'SamplesPerPixel',\n\
        0x0116: 'RowsPerStrip',\n\
        0x0117: 'StripByteCounts',\n\
        0x011a: 'XResolution',\n\
        0x011b: 'YResolution',\n\
        0x011c: 'PlanarConfiguration',\n\
        0x0128: {\n\
          'name': 'ResolutionUnit',\n\
          'description': function(value) {\n\
            switch (value) {\n\
              case 2:\n\
                return 'inches';\n\
              case 3:\n\
                return 'centimeters';\n\
              default:\n\
                return 'Unknown';\n\
            }\n\
          }\n\
        },\n\
        0x012d: 'TransferFunction',\n\
        0x0131: 'Software',\n\
        0x0132: 'DateTime',\n\
        0x013b: 'Artist',\n\
        0x013e: 'WhitePoint',\n\
        0x013f: 'PrimaryChromaticities',\n\
        0x0201: 'JPEGInterchangeFormat',\n\
        0x0202: 'JPEGInterchangeFormatLength',\n\
        0x0211: 'YCbCrCoefficients',\n\
        0x0212: 'YCbCrSubSampling',\n\
        0x0213: {\n\
          'name': 'YCbCrPositioning',\n\
          'description': function(value) {\n\
            switch (value) {\n\
              case 1:\n\
                return 'centered';\n\
              case 2:\n\
                return 'co-sited';\n\
              default:\n\
                return 'undefied ' + value;\n\
            }\n\
          }\n\
        },\n\
        0x0214: 'ReferenceBlackWhite',\n\
        0x8298: {\n\
          'name': 'Copyright',\n\
          'description': function(value) {\n\
            return value.join('; ');\n\
          }\n\
        },\n\
        0x8769: 'Exif IFD Pointer',\n\
        0x8825: 'GPS Info IFD Pointer'\n\
      },\n\
      'exif': {\n\
        0x829a: 'ExposureTime',\n\
        0x829d: 'FNumber',\n\
        0x8822: {\n\
          'name': 'ExposureProgram',\n\
          'description': function(value) {\n\
            switch (value) {\n\
              case 0:\n\
                return 'Undefined';\n\
              case 1:\n\
                return 'Manual';\n\
              case 2:\n\
                return 'Normal program';\n\
              case 3:\n\
                return 'Aperture priority';\n\
              case 4:\n\
                return 'Shutter priority';\n\
              case 5:\n\
                return 'Creative program';\n\
              case 6:\n\
                return 'Action program';\n\
              case 7:\n\
                return 'Portrait mode';\n\
              case 8:\n\
                return 'Landscape mode';\n\
              default:\n\
                return 'Unknown';\n\
            }\n\
          }\n\
        },\n\
        0x8824: 'SpectralSensitivity',\n\
        0x8827: 'ISOSpeedRatings',\n\
        0x8828: {\n\
          'name': 'OECF',\n\
          'description': function(value) {\n\
            return '[Raw OECF table data]';\n\
          }\n\
        },\n\
        0x9000: {\n\
          'name': 'ExifVersion',\n\
          'description': function(value) {\n\
            var charCode, string, _i, _len;\n\
\n\
            string = '';\n\
            for (_i = 0, _len = value.length; _i < _len; _i++) {\n\
              charCode = value[_i];\n\
              string += String.fromCharCode(charCode);\n\
            }\n\
            return string;\n\
          }\n\
        },\n\
        0x9003: 'DateTimeOriginal',\n\
        0x9004: 'DateTimeDigitized',\n\
        0x9101: {\n\
          'name': 'ComponentsConfiguration',\n\
          'description': function(value) {\n\
            var character, string, _i, _len;\n\
\n\
            string = '';\n\
            for (_i = 0, _len = value.length; _i < _len; _i++) {\n\
              character = value[_i];\n\
              switch (character) {\n\
                case 0x31:\n\
                  string += 'Y';\n\
                  break;\n\
                case 0x32:\n\
                  string += 'Cb';\n\
                  break;\n\
                case 0x33:\n\
                  string += 'Cr';\n\
                  break;\n\
                case 0x34:\n\
                  string += 'R';\n\
                  break;\n\
                case 0x35:\n\
                  string += 'G';\n\
                  break;\n\
                case 0x36:\n\
                  string += 'B';\n\
              }\n\
            }\n\
            return string;\n\
          }\n\
        },\n\
        0x9102: 'CompressedBitsPerPixel',\n\
        0x9201: 'ShutterSpeedValue',\n\
        0x9202: 'ApertureValue',\n\
        0x9203: 'BrightnessValue',\n\
        0x9204: 'ExposureBiasValue',\n\
        0x9205: 'MaxApertureValue',\n\
        0x9206: 'SubjectDistance',\n\
        0x9207: {\n\
          'name': 'MeteringMode',\n\
          'description': function(value) {\n\
            switch (value) {\n\
              case 1:\n\
                return 'Average';\n\
              case 2:\n\
                return 'CenterWeightedAverage';\n\
              case 3:\n\
                return 'Spot';\n\
              case 4:\n\
                return 'MultiSpot';\n\
              case 5:\n\
                return 'Pattern';\n\
              case 6:\n\
                return 'Partial';\n\
              case 255:\n\
                return 'Other';\n\
              default:\n\
                return 'Unknown';\n\
            }\n\
          }\n\
        },\n\
        0x9208: {\n\
          'name': 'LightSource',\n\
          'description': function(value) {\n\
            switch (value) {\n\
              case 1:\n\
                return 'Daylight';\n\
              case 2:\n\
                return 'Fluorescent';\n\
              case 3:\n\
                return 'Tungsten (incandescent light)';\n\
              case 4:\n\
                return 'Flash';\n\
              case 9:\n\
                return 'Fine weather';\n\
              case 10:\n\
                return 'Cloudy weather';\n\
              case 11:\n\
                return 'Shade';\n\
              case 12:\n\
                return 'Daylight fluorescent (D 5700 – 7100K)';\n\
              case 13:\n\
                return 'Day white fluorescent (N 4600 – 5400K)';\n\
              case 14:\n\
                return 'Cool white fluorescent (W 3900 – 4500K)';\n\
              case 15:\n\
                return 'White fluorescent (WW 3200 – 3700K)';\n\
              case 17:\n\
                return 'Standard light A';\n\
              case 18:\n\
                return 'Standard light B';\n\
              case 19:\n\
                return 'Standard light C';\n\
              case 20:\n\
                return 'D55';\n\
              case 21:\n\
                return 'D65';\n\
              case 22:\n\
                return 'D75';\n\
              case 23:\n\
                return 'D50';\n\
              case 24:\n\
                return 'ISO studio tungsten';\n\
              case 255:\n\
                return 'Other light source';\n\
              default:\n\
                return 'Unknown';\n\
            }\n\
          }\n\
        },\n\
        0x9209: {\n\
          'name': 'Flash',\n\
          'description': function(value) {\n\
            switch (value) {\n\
              case 0x00:\n\
                return 'Flash did not fire';\n\
              case 0x01:\n\
                return 'Flash fired';\n\
              case 0x05:\n\
                return 'Strobe return light not detected';\n\
              case 0x07:\n\
                return 'Strobe return light detected';\n\
              case 0x09:\n\
                return 'Flash fired, compulsory flash mode';\n\
              case 0x0d:\n\
                return 'Flash fired, compulsory flash mode, return light not detected';\n\
              case 0x0f:\n\
                return 'Flash fired, compulsory flash mode, return light detected';\n\
              case 0x10:\n\
                return 'Flash did not fire, compulsory flash mode';\n\
              case 0x18:\n\
                return 'Flash did not fire, auto mode';\n\
              case 0x19:\n\
                return 'Flash fired, auto mode';\n\
              case 0x1d:\n\
                return 'Flash fired, auto mode, return light not detected';\n\
              case 0x1f:\n\
                return 'Flash fired, auto mode, return light detected';\n\
              case 0x20:\n\
                return 'No flash function';\n\
              case 0x41:\n\
                return 'Flash fired, red-eye reduction mode';\n\
              case 0x45:\n\
                return 'Flash fired, red-eye reduction mode, return light not detected';\n\
              case 0x47:\n\
                return 'Flash fired, red-eye reduction mode, return light detected';\n\
              case 0x49:\n\
                return 'Flash fired, compulsory flash mode, red-eye reduction mode';\n\
              case 0x4d:\n\
                return 'Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected';\n\
              case 0x4f:\n\
                return 'Flash fired, compulsory flash mode, red-eye reduction mode, return light detected';\n\
              case 0x59:\n\
                return 'Flash fired, auto mode, red-eye reduction mode';\n\
              case 0x5d:\n\
                return 'Flash fired, auto mode, return light not detected, red-eye reduction mode';\n\
              case 0x5f:\n\
                return 'Flash fired, auto mode, return light detected, red-eye reduction mode';\n\
              default:\n\
                return 'Unknown';\n\
            }\n\
          }\n\
        },\n\
        0x920a: 'FocalLength',\n\
        0x9214: {\n\
          'name': 'SubjectArea',\n\
          'description': function(value) {\n\
            switch (value.length) {\n\
              case 2:\n\
                return \"Location; X: \" + value[0] + \", Y: \" + value[1];\n\
              case 3:\n\
                return \"Circle; X: \" + value[0] + \", Y: \" + value[1] + \", diameter: \" + value[2];\n\
              case 4:\n\
                return \"Rectangle; X: \" + value[0] + \", Y: \" + value[1] + \", width: \" + value[2] + \", height: \" + value[3];\n\
              default:\n\
                return 'Unknown';\n\
            }\n\
          }\n\
        },\n\
        0x927c: {\n\
          'name': 'MakerNote',\n\
          'description': function(value) {\n\
            return '[Raw maker note data]';\n\
          }\n\
        },\n\
        0x9286: {\n\
          'name': 'UserComment',\n\
          'description': function(value) {\n\
            switch (value.slice(0, 8).map(function(charCode) {\n\
                  return String.fromCharCode(charCode);\n\
                }).join('')) {\n\
              case 'ASCII\\x00\\x00\\x00':\n\
                return value.slice(8, value.length).map(function(charCode) {\n\
                  return String.fromCharCode(charCode);\n\
                }).join('');\n\
              case 'JIS\\x00\\x00\\x00\\x00\\x00':\n\
                return '[JIS encoded text]';\n\
              case 'UNICODE\\x00':\n\
                return '[Unicode encoded text]';\n\
              case '\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00':\n\
                return '[Undefined encoding]';\n\
            }\n\
          }\n\
        },\n\
        0x9290: 'SubSecTime',\n\
        0x9291: 'SubSecTimeOriginal',\n\
        0x9292: 'SubSecTimeDigitized',\n\
        0xa000: {\n\
          'name': 'FlashpixVersion',\n\
          'description': function(value) {\n\
            var charCode, string, _i, _len;\n\
\n\
            string = '';\n\
            for (_i = 0, _len = value.length; _i < _len; _i++) {\n\
              charCode = value[_i];\n\
              string += String.fromCharCode(charCode);\n\
            }\n\
            return string;\n\
          }\n\
        },\n\
        0xa001: {\n\
          'name': 'ColorSpace',\n\
          'description': function(value) {\n\
            switch (value) {\n\
              case 1:\n\
                return 'sRGB';\n\
              case 0xffff:\n\
                return 'Uncalibrated';\n\
              default:\n\
                return 'Unknown';\n\
            }\n\
          }\n\
        },\n\
        0xa002: 'PixelXDimension',\n\
        0xa003: 'PixelYDimension',\n\
        0xa004: 'RelatedSoundFile',\n\
        0xa005: 'Interoperability IFD Pointer',\n\
        0xa20b: 'FlashEnergy',\n\
        0xa20c: {\n\
          'name': 'SpatialFrequencyResponse',\n\
          'description': function(value) {\n\
            return '[Raw SFR table data]';\n\
          }\n\
        },\n\
        0xa20e: 'FocalPlaneXResolution',\n\
        0xa20f: 'FocalPlaneYResolution',\n\
        0xa210: {\n\
          'name': 'FocalPlaneResolutionUnit',\n\
          'description': function(value) {\n\
            switch (value) {\n\
              case 2:\n\
                return 'inches';\n\
              case 3:\n\
                return 'centimeters';\n\
              default:\n\
                return 'Unknown';\n\
            }\n\
          }\n\
        },\n\
        0xa214: {\n\
          'name': 'SubjectLocation',\n\
          'description': function(value) {\n\
            return \"X: \" + value[0] + \", Y: \" + value[1];\n\
          }\n\
        },\n\
        0xa215: 'ExposureIndex',\n\
        0xa217: {\n\
          'name': 'SensingMethod',\n\
          'description': function(value) {\n\
            switch (value) {\n\
              case 1:\n\
                return 'Undefined';\n\
              case 2:\n\
                return 'One-chip color area sensor';\n\
              case 3:\n\
                return 'Two-chip color area sensor';\n\
              case 4:\n\
                return 'Three-chip color area sensor';\n\
              case 5:\n\
                return 'Color sequential area sensor';\n\
              case 7:\n\
                return 'Trilinear sensor';\n\
              case 8:\n\
                return 'Color sequential linear sensor';\n\
              default:\n\
                return 'Unknown';\n\
            }\n\
          }\n\
        },\n\
        0xa300: {\n\
          'name': 'FileSource',\n\
          'description': function(value) {\n\
            switch (value) {\n\
              case 3:\n\
                return 'DSC';\n\
              default:\n\
                return 'Unknown';\n\
            }\n\
          }\n\
        },\n\
        0xa301: {\n\
          'name': 'SceneType',\n\
          'description': function(value) {\n\
            switch (value) {\n\
              case 1:\n\
                return 'A directly photographed image';\n\
              default:\n\
                return 'Unknown';\n\
            }\n\
          }\n\
        },\n\
        0xa302: {\n\
          'name': 'CFAPattern',\n\
          'description': function(value) {\n\
            return '[Raw CFA pattern table data]';\n\
          }\n\
        },\n\
        0xa401: {\n\
          'name': 'CustomRendered',\n\
          'description': function(value) {\n\
            switch (value) {\n\
              case 0:\n\
                return 'Normal process';\n\
              case 1:\n\
                return 'Custom process';\n\
              default:\n\
                return 'Unknown';\n\
            }\n\
          }\n\
        },\n\
        0xa402: {\n\
          'name': 'ExposureMode',\n\
          'description': function(value) {\n\
            switch (value) {\n\
              case 0:\n\
                return 'Auto exposure';\n\
              case 1:\n\
                return 'Manual exposure';\n\
              case 2:\n\
                return 'Auto bracket';\n\
              default:\n\
                return 'Unknown';\n\
            }\n\
          }\n\
        },\n\
        0xa403: {\n\
          'name': 'WhiteBalance',\n\
          'description': function(value) {\n\
            switch (value) {\n\
              case 0:\n\
                return 'Auto white balance';\n\
              case 1:\n\
                return 'Manual white balance';\n\
              default:\n\
                return 'Unknown';\n\
            }\n\
          }\n\
        },\n\
        0xa404: {\n\
          'name': 'DigitalZoomRatio',\n\
          'description': function(value) {\n\
            switch (value) {\n\
              case 0:\n\
                return 'Digital zoom was not used';\n\
              default:\n\
                return value;\n\
            }\n\
          }\n\
        },\n\
        0xa405: {\n\
          'name': 'FocalLengthIn35mmFilm',\n\
          'description': function(value) {\n\
            switch (value) {\n\
              case 0:\n\
                return 'Unknown';\n\
              default:\n\
                return value;\n\
            }\n\
          }\n\
        },\n\
        0xa406: {\n\
          'name': 'SceneCaptureType',\n\
          'description': function(value) {\n\
            switch (value) {\n\
              case 0:\n\
                return 'Standard';\n\
              case 1:\n\
                return 'Landscape';\n\
              case 2:\n\
                return 'Portrait';\n\
              case 3:\n\
                return 'Night scene';\n\
              default:\n\
                return 'Unknown';\n\
            }\n\
          }\n\
        },\n\
        0xa407: {\n\
          'name': 'GainControl',\n\
          'description': function(value) {\n\
            switch (value) {\n\
              case 0:\n\
                return 'None';\n\
              case 1:\n\
                return 'Low gain up';\n\
              case 2:\n\
                return 'High gain up';\n\
              case 3:\n\
                return 'Low gain down';\n\
              case 4:\n\
                return 'High gain down';\n\
              default:\n\
                return 'Unknown';\n\
            }\n\
          }\n\
        },\n\
        0xa408: {\n\
          'name': 'Contrast',\n\
          'description': function(value) {\n\
            switch (value) {\n\
              case 0:\n\
                return 'Normal';\n\
              case 1:\n\
                return 'Soft';\n\
              case 2:\n\
                return 'Hard';\n\
              default:\n\
                return 'Unknown';\n\
            }\n\
          }\n\
        },\n\
        0xa409: {\n\
          'name': 'Saturation',\n\
          'description': function(value) {\n\
            switch (value) {\n\
              case 0:\n\
                return 'Normal';\n\
              case 1:\n\
                return 'Low saturation';\n\
              case 2:\n\
                return 'High saturation';\n\
              default:\n\
                return 'Unknown';\n\
            }\n\
          }\n\
        },\n\
        0xa40a: {\n\
          'name': 'Sharpness',\n\
          'description': function(value) {\n\
            switch (value) {\n\
              case 0:\n\
                return 'Normal';\n\
              case 1:\n\
                return 'Soft';\n\
              case 2:\n\
                return 'Hard';\n\
              default:\n\
                return 'Unknown';\n\
            }\n\
          }\n\
        },\n\
        0xa40b: {\n\
          'name': 'DeviceSettingDescription',\n\
          'description': function(value) {\n\
            return '[Raw device settings table data]';\n\
          }\n\
        },\n\
        0xa40c: {\n\
          'name': 'SubjectDistanceRange',\n\
          'description': function(value) {\n\
            switch (value) {\n\
              case 1:\n\
                return 'Macro';\n\
              case 2:\n\
                return 'Close view';\n\
              case 3:\n\
                return 'Distant view';\n\
              default:\n\
                return 'Unknown';\n\
            }\n\
          }\n\
        },\n\
        0xa420: 'ImageUniqueID'\n\
      },\n\
      'gps': {\n\
        0x0000: {\n\
          'name': 'GPSVersionID',\n\
          'description': function(value) {\n\
            var _ref, _ref1;\n\
\n\
            if ((value[0] === (_ref = value[1]) && _ref === 2) && (value[2] === (_ref1 = value[3]) && _ref1 === 0)) {\n\
              return 'Version 2.2';\n\
            } else {\n\
              return 'Unknown';\n\
            }\n\
          }\n\
        },\n\
        0x0001: {\n\
          'name': 'GPSLatitudeRef',\n\
          'description': function(value) {\n\
            switch (value.join('')) {\n\
              case 'N':\n\
                return 'North latitude';\n\
              case 'S':\n\
                return 'South latitude';\n\
              default:\n\
                return 'Unknown';\n\
            }\n\
          }\n\
        },\n\
        0x0002: {\n\
          'name': 'GPSLatitude',\n\
          'description': function(value) {\n\
            return value[0] + value[1] / 60 + value[2] / 3600;\n\
          }\n\
        },\n\
        0x0003: {\n\
          'name': 'GPSLongitudeRef',\n\
          'description': function(value) {\n\
            switch (value.join('')) {\n\
              case 'E':\n\
                return 'East longitude';\n\
              case 'W':\n\
                return 'West longitude';\n\
              default:\n\
                return 'Unknown';\n\
            }\n\
          }\n\
        },\n\
        0x0004: {\n\
          'name': 'GPSLongitude',\n\
          'description': function(value) {\n\
            return value[0] + value[1] / 60 + value[2] / 3600;\n\
          }\n\
        },\n\
        0x0005: {\n\
          'name': 'GPSAltitudeRef',\n\
          'description': function(value) {\n\
            switch (value) {\n\
              case 0:\n\
                return 'Sea level';\n\
              case 1:\n\
                return 'Sea level reference (negative value)';\n\
              default:\n\
                return 'Unknown';\n\
            }\n\
          }\n\
        },\n\
        0x0006: {\n\
          'name': 'GPSAltitude',\n\
          'description': function(value) {\n\
            return value + ' m';\n\
          }\n\
        },\n\
        0x0007: {\n\
          'name': 'GPSTimeStamp',\n\
          'description': function(value) {\n\
            var padZero;\n\
\n\
            padZero = function(num) {\n\
              var i;\n\
\n\
              return ((function() {\n\
                var _i, _ref, _results;\n\
\n\
                _results = [];\n\
                for (i = _i = 0, _ref = 2 - ('' + Math.floor(num)).length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n\
                  _results.push('0');\n\
                }\n\
                return _results;\n\
              })()) + num;\n\
            };\n\
            return value.map(padZero).join(':');\n\
          }\n\
        },\n\
        0x0008: 'GPSSatellites',\n\
        0x0009: {\n\
          'name': 'GPSStatus',\n\
          'description': function(value) {\n\
            switch (value.join('')) {\n\
              case 'A':\n\
                return 'Measurement in progress';\n\
              case 'V':\n\
                return 'Measurement Interoperability';\n\
              default:\n\
                return 'Unknown';\n\
            }\n\
          }\n\
        },\n\
        0x000a: {\n\
          'name': 'GPSMeasureMode',\n\
          'description': function(value) {\n\
            switch (value.join('')) {\n\
              case '2':\n\
                return '2-dimensional measurement';\n\
              case '3':\n\
                return '3-dimensional measurement';\n\
              default:\n\
                return 'Unknown';\n\
            }\n\
          }\n\
        },\n\
        0x000b: 'GPSDOP',\n\
        0x000c: {\n\
          'name': 'GPSSpeedRef',\n\
          'description': function(value) {\n\
            switch (value.join('')) {\n\
              case 'K':\n\
                return 'Kilometers per hour';\n\
              case 'M':\n\
                return 'Miles per hour';\n\
              case 'N':\n\
                return 'Knots';\n\
              default:\n\
                return 'Unknown';\n\
            }\n\
          }\n\
        },\n\
        0x000d: 'GPSSpeed',\n\
        0x000e: {\n\
          'name': 'GPSTrackRef',\n\
          'description': function(value) {\n\
            switch (value.join('')) {\n\
              case 'T':\n\
                return 'True direction';\n\
              case 'M':\n\
                return 'Magnetic direction';\n\
              default:\n\
                return 'Unknown';\n\
            }\n\
          }\n\
        },\n\
        0x000f: 'GPSTrack',\n\
        0x0010: {\n\
          'name': 'GPSImgDirectionRef',\n\
          'description': function(value) {\n\
            switch (value.join('')) {\n\
              case 'T':\n\
                return 'True direction';\n\
              case 'M':\n\
                return 'Magnetic direction';\n\
              default:\n\
                return 'Unknown';\n\
            }\n\
          }\n\
        },\n\
        0x0011: 'GPSImgDirection',\n\
        0x0012: 'GPSMapDatum',\n\
        0x0013: {\n\
          'name': 'GPSDestLatitudeRef',\n\
          'description': function(value) {\n\
            switch (value.join('')) {\n\
              case 'N':\n\
                return 'North latitude';\n\
              case 'S':\n\
                return 'South latitude';\n\
              default:\n\
                return 'Unknown';\n\
            }\n\
          }\n\
        },\n\
        0x0014: {\n\
          'name': 'GPSDestLatitude',\n\
          'description': function(value) {\n\
            return value[0] + value[1] / 60 + value[2] / 3600;\n\
          }\n\
        },\n\
        0x0015: {\n\
          'name': 'GPSDestLongitudeRef',\n\
          'description': function(value) {\n\
            switch (value.join('')) {\n\
              case 'E':\n\
                return 'East longitude';\n\
              case 'W':\n\
                return 'West longitude';\n\
              default:\n\
                return 'Unknown';\n\
            }\n\
          }\n\
        },\n\
        0x0016: {\n\
          'name': 'GPSDestLongitude',\n\
          'description': function(value) {\n\
            return value[0] + value[1] / 60 + value[2] / 3600;\n\
          }\n\
        },\n\
        0x0017: {\n\
          'name': 'GPSDestBearingRef',\n\
          'description': function(value) {\n\
            switch (value.join('')) {\n\
              case 'T':\n\
                return 'True direction';\n\
              case 'M':\n\
                return 'Magnetic direction';\n\
              default:\n\
                return 'Unknown';\n\
            }\n\
          }\n\
        },\n\
        0x0018: 'GPSDestBearing',\n\
        0x0019: {\n\
          'name': 'GPSDestDistanceRef',\n\
          'description': function(value) {\n\
            switch (value.join('')) {\n\
              case 'K':\n\
                return 'Kilometers';\n\
              case 'M':\n\
                return 'Miles';\n\
              case 'N':\n\
                return 'Knots';\n\
              default:\n\
                return 'Unknown';\n\
            }\n\
          }\n\
        },\n\
        0x001a: 'GPSDestDistance',\n\
        0x001b: {\n\
          'name': 'GPSProcessingMethod',\n\
          'description': function(value) {\n\
            if (value === 0) {\n\
              return 'Undefined';\n\
            } else {\n\
              switch (value.slice(0, 8).map(function(charCode) {\n\
                    return String.fromCharCode(charCode);\n\
                  }).join('')) {\n\
                case 'ASCII\\x00\\x00\\x00':\n\
                  return value.slice(8, value.length).map(function(charCode) {\n\
                    return String.fromCharCode(charCode);\n\
                  }).join('');\n\
                case 'JIS\\x00\\x00\\x00\\x00\\x00':\n\
                  return '[JIS encoded text]';\n\
                case 'UNICODE\\x00':\n\
                  return '[Unicode encoded text]';\n\
                case '\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00':\n\
                  return '[Undefined encoding]';\n\
              }\n\
            }\n\
          }\n\
        },\n\
        0x001c: {\n\
          'name': 'GPSAreaInformation',\n\
          'description': function(value) {\n\
            if (value === 0) {\n\
              return 'Undefined';\n\
            } else {\n\
              switch (value.slice(0, 8).map(function(charCode) {\n\
                    return String.fromCharCode(charCode);\n\
                  }).join('')) {\n\
                case 'ASCII\\x00\\x00\\x00':\n\
                  return value.slice(8, value.length).map(function(charCode) {\n\
                    return String.fromCharCode(charCode);\n\
                  }).join('');\n\
                case 'JIS\\x00\\x00\\x00\\x00\\x00':\n\
                  return '[JIS encoded text]';\n\
                case 'UNICODE\\x00':\n\
                  return '[Unicode encoded text]';\n\
                case '\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00':\n\
                  return '[Undefined encoding]';\n\
              }\n\
            }\n\
          }\n\
        },\n\
        0x001d: 'GPSDateStamp',\n\
        0x001e: {\n\
          'name': 'GPSDifferential',\n\
          'description': function(value) {\n\
            switch (value) {\n\
              case 0:\n\
                return 'Measurement without differential correction';\n\
              case 1:\n\
                return 'Differential correction applied';\n\
              default:\n\
                return 'Unknown';\n\
            }\n\
          }\n\
        }\n\
      },\n\
      'interoperability': {\n\
        0x0001: 'InteroperabilityIndex',\n\
        0x0002: 'UnknownInteroperabilityTag0x0002',\n\
        0x1001: 'UnknownInteroperabilityTag0x1001',\n\
        0x1002: 'UnknownInteroperabilityTag0x1002'\n\
      }\n\
    };\n\
\n\
    /*\n\
    # Gets the image's value of the tag with the given name.\n\
    #\n\
    # name string The name of the tag to get the value of\n\
    #\n\
    # Returns the value of the tag with the given name if it exists,\n\
    # otherwise throws \"Undefined\".\n\
    */\n\
\n\
\n\
    ExifReader.prototype.getTagValue = function(name) {\n\
      if (this._tags[name] != null) {\n\
        return this._tags[name].value;\n\
      } else {\n\
        return void 0;\n\
      }\n\
    };\n\
\n\
    /*\n\
    # Gets the image's description of the tag with the given name.\n\
    #\n\
    # name string The name of the tag to get the description of\n\
    #\n\
    # Returns the description of the tag with the given name if it exists,\n\
    # otherwise throws \"Undefined\".\n\
    */\n\
\n\
\n\
    ExifReader.prototype.getTagDescription = function(name) {\n\
      if (this._tags[name] != null) {\n\
        return this._tags[name].description;\n\
      } else {\n\
        return void 0;\n\
      }\n\
    };\n\
\n\
    /*\n\
    # Gets all the image's tags.\n\
    #\n\
    # Returns the image's tags as an associative array: name -> description.\n\
    */\n\
\n\
\n\
    ExifReader.prototype.getAllTags = function() {\n\
      return this._tags;\n\
    };\n\
\n\
    /*\n\
    # Delete a tag.\n\
    #\n\
    # name string The name of the tag to delete\n\
    #\n\
    # Delete the tag with the given name. Can be used to lower memory usage.\n\
    # E.g., the MakerNote tag can be really large.\n\
    */\n\
\n\
\n\
    ExifReader.prototype.deleteTag = function(name) {\n\
      return delete this._tags[name];\n\
    };\n\
\n\
    return ExifReader;\n\
\n\
  })();\n\
\n\
}).call(this);\n\
\n\
//# sourceURL=components/mattiasw/exifreader/v1.1.1/js/ExifReader.js"
));

require.modules["mattiasw-exifreader"] = require.modules["mattiasw~exifreader@v1.1.1"];
require.modules["mattiasw~exifreader"] = require.modules["mattiasw~exifreader@v1.1.1"];
require.modules["exifreader"] = require.modules["mattiasw~exifreader@v1.1.1"];


require.register("exiflocation", Function("exports, module",
"'use strict';\n\
\n\
var ExifReader = require('mattiasw~exifreader@v1.1.1').ExifReader;\n\
\n\
module.exports = ExifLocation;\n\
\n\
\n\
/**\n\
 * @constructor\n\
 */\n\
function ExifLocation() {\n\
\tthis.loading = false;\n\
\tthis.exifReader = null;\n\
\tthis.err = null;\n\
}\n\
\n\
\n\
/**\n\
 * Factory method for producing an array of ExifLocation instances from a FileList.\n\
 *\n\
 * @param {FileList} fileList\n\
 * @param {function} progressCb Progress callback executed once every time an item in the list is loaded, receiving the list index as the third argument\n\
 * @param {function} cb Callback function executed when the entire list is loaded, with the list as the first and only argument\n\
 */\n\
ExifLocation.loadFromFileList = function(fileList, progressCb, cb) {\n\
\tvar i, l, countDown, exifLocation, exifLocationList, innerCb;\n\
\n\
\tif (!(fileList instanceof FileList)) {\n\
\t\tthrow new TypeError('Expecting FileList, received \"' + fileList + '\".');\n\
\t}\n\
\n\
\tinnerCb = function(i) {\n\
\t\treturn function(err, exifLocation) {\n\
\t\t\tcountDown--;\n\
\t\t\texifLocationList[i] = exifLocation;\n\
\t\t\tif (progressCb) {\n\
\t\t\t\tprogressCb(err, exifLocation, i);\n\
\t\t\t}\n\
\n\
\t\t\tif (countDown === 0 && cb) {\n\
\t\t\t\tcb(exifLocationList);\n\
\t\t\t}\n\
\t\t};\n\
\t};\n\
\n\
\t// TODO: Only create and push to this list if cb is not null.\n\
\texifLocationList = [];\n\
\tcountDown = fileList.length;\n\
\tfor (i = 0, l = countDown; i < l; i++) {\n\
\t\texifLocation = new ExifLocation();\n\
\t\texifLocation.loadFromFile(fileList[i], innerCb(i));\n\
\t}\n\
};\n\
\n\
\n\
/**\n\
 * Load from a File.\n\
 *\n\
 * @param {File} file\n\
 * @param {function} cb Callback receives an Error object or null as the first argument and the ExifLocation instance as the second argument.\n\
 */\n\
ExifLocation.prototype.loadFromFile = function(file, cb) {\n\
\tvar fileReader, self = this;\n\
\n\
\tif (this.loading) {\n\
\t\tthrow new Error('Already loading.');\n\
\t}\n\
\n\
\tif (!(file instanceof File)) {\n\
\t\tthrow new TypeError('Expecting File, received \"' + file + '\".');\n\
\t}\n\
\n\
\tthis.loading = true;\n\
\n\
\tfileReader = new FileReader();\n\
\tfileReader.onload = function(event) {\n\
\t\tself.loading = false;\n\
\t\tself.loadFromArrayBuffer(event.target.result, cb);\n\
\t};\n\
\n\
\tfileReader.readAsArrayBuffer(file);\n\
};\n\
\n\
\n\
/**\n\
 * Load from an ArrayBuffer.\n\
 *\n\
 * @param {ArrayBuffer} arrayBuffer\n\
 * @param {function} cb Callback receives an Error object or null as the first argument and the ExifLocation instance as the second argument.\n\
 */\n\
ExifLocation.prototype.loadFromArrayBuffer = function(arrayBuffer, cb) {\n\
\tvar exifReader;\n\
\n\
\tif (this.exifReader) {\n\
\t\tthrow new Error('Already loaded.');\n\
\t}\n\
\n\
\texifReader = new ExifReader();\n\
\ttry {\n\
\n\
\t\t// Parse the Exif tags.\n\
\t\texifReader.load(arrayBuffer);\n\
\n\
\t\t// Or, with jDataView you would use this:\n\
\t\t// exif.loadView(new jDataView(arrayBuffer));\n\
\n\
\t} catch (err) {\n\
\t\tthis.err = err;\n\
\t\treturn cb(err, this);\n\
\t}\n\
\n\
\tthis.exifReader = exifReader;\n\
\tcb(null, this);\n\
};\n\
\n\
\n\
/**\n\
 * Get the longitude from the image EXIF GPS data.\n\
 *\n\
 * @return {number|boolean} Return false if GPS data is not available\n\
 */\n\
ExifLocation.prototype.getLongitude = function() {\n\
\tvar longitude, longitudeRef;\n\
\n\
\tif (!this.exifReader) {\n\
\t\tthrow new Error('Not loaded.');\n\
\t}\n\
\n\
\tlongitude = this.exifReader.getTagDescription('GPSLongitude');\n\
\tif (!longitude) {\n\
\t\treturn false;\n\
\t}\n\
\n\
\tlongitudeRef = this.exifReader.getTagDescription('GPSLongitudeRef');\n\
\tif (longitudeRef === 'West longitude') {\n\
\t\tlongitude = longitude * -1;\n\
\t}\n\
\n\
\treturn longitude;\n\
};\n\
\n\
\n\
/**\n\
 * Get the latitude from the image EXIF GPS data.\n\
 *\n\
 * @return {number|boolean} Return false if GPS data is not available\n\
 */\n\
ExifLocation.prototype.getLatitude = function() {\n\
\tvar latitude, latitudeRef;\n\
\n\
\tif (!this.exifReader) {\n\
\t\tthrow new Error('Not loaded.');\n\
\t}\n\
\n\
\tlatitude = this.exifReader.getTagDescription('GPSLatitude');\n\
\tif (!latitude) {\n\
\t\treturn false;\n\
\t}\n\
\n\
\tlatitudeRef = this.exifReader.getTagDescription('GPSLatitudeRef');\n\
\tif (latitudeRef === 'South latitude') {\n\
\t\tlatitude = latitude * -1;\n\
\t}\n\
\n\
\treturn latitude;\n\
};\n\
\n\
\n\
/**\n\
 * Get a Google Maps URL for the image EXIF GPS coordinates.\n\
 *\n\
 * @param {string} protocol Either 'http:', 'https:' or empty for a protocol relative URL\n\
 * @param {string|number} zoom Zoom level for the map (1-20), defaults to 10\n\
 * @param {string} type Map type, either 'm' for the normal map (default), 'k' for satellite, 'h' for hybrid, 'p' for terrain or 'e' for Google Earth\n\
 * @return {string|boolean} Google Maps URL for the location, or false if no data points available\n\
 */\n\
ExifLocation.prototype.getGoogleMapsUrl = function(protocol, zoom, type) {\n\
\tvar latitude, longitude;\n\
\n\
\tif (!protocol) {\n\
\t\tprotocol = '';\n\
\t}\n\
\n\
\tif (!zoom) {\n\
\t\tzoom = '10';\n\
\t}\n\
\n\
\tif (!type) {\n\
\t\ttype = 'm';\n\
\t}\n\
\n\
\tlatitude = this.getLatitude();\n\
\tlongitude = this.getLongitude();\n\
\tif (!latitude || !longitude) {\n\
\t\treturn false;\n\
\t}\n\
\n\
\treturn protocol + '//maps.google.com/maps?z=' + zoom + '&t=' + type + '&q=loc:' + latitude + '+' + longitude;\n\
};\n\
\n\
\n\
/**\n\
 * Check if the JavaScript runtime supports the interfaces required by ExifLocation.\n\
 *\n\
 * @return {boolean}\n\
 */\n\
ExifLocation.checkSupport = function() {\n\
\treturn !(!FileReader || !DataView);\n\
};\n\
\n\
//# sourceURL=static/js/ExifLocation.js"
));

require.modules["exiflocation"] = require.modules["exiflocation"];


require("exiflocation");
